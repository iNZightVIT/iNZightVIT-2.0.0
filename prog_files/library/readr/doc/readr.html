<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Vector parsers</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>The key problem that readr solves is <strong>parsing</strong> a flat file into a tibble. Parsing is the process of taking a text file and turning it into a rectangular tibble where each column is the appropriate part. Parsing takes place in three basic stages:</p>

<ol>
<li><p>The flat file is parsed into a rectangular matrix of
strings.</p></li>
<li><p>The type of each column is determined.</p></li>
<li><p>Each column of strings is parsed into a vector of a 
more specific type.</p></li>
</ol>

<p>It&#39;s easiest to learn how this works in the opposite order Below, you&#39;ll learn how the:</p>

<ol>
<li><p><strong>Vector parsers</strong> turn a character vector in to a 
more specific type. </p></li>
<li><p><strong>Column specification</strong> describes the type of each 
column and the strategy readr uses to guess types so
you don&#39;t need to supply them all.</p></li>
<li><p><strong>Rectangular parsers</strong> turn a flat file into a 
matrix of rows and columns.</p></li>
</ol>

<p>Each <code>parse_*()</code> is coupled with a <code>col_*()</code> function, which will be used in the process of parsing a complete tibble. </p>

<h2>Vector parsers</h2>

<p>It&#39;s easiest to learn the vector parses using <code>parse_</code> functions. These all take a character vector and some options. They return a new vector the same length as the old, along with an attribute describing any problems.</p>

<h3>Atomic vectors</h3>

<p><code>parse_logical()</code>, <code>parse_integer()</code>, <code>parse_double()</code>, and <code>parse_character()</code> are straightforward parsers that produce the corresponding atomic vector.</p>

<pre><code class="r">parse_integer(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))
#&gt; [1] 1 2 3
parse_double(c(&quot;1.56&quot;, &quot;2.34&quot;, &quot;3.56&quot;))
#&gt; [1] 1.56 2.34 3.56
parse_logical(c(&quot;true&quot;, &quot;false&quot;))
#&gt; [1]  TRUE FALSE
</code></pre>

<p>By default, readr expects <code>.</code> as the decimal mark and <code>,</code> as the grouping mark. You can override this default using <code>locale()</code>, as described in <code>vignette(&quot;locales&quot;)</code>.</p>

<h3>Flexible numeric parser</h3>

<p><code>parse_integer()</code> and <code>parse_double()</code> are strict: the input string must be a single number with no leading or trailing characters. <code>parse_number()</code> is more flexible: it ignores non-numeric prefixes and suffixes, and knows how to deal with grouping marks. This makes it suitable for reading currencies and percentages:</p>

<pre><code class="r">parse_number(c(&quot;0%&quot;, &quot;10%&quot;, &quot;150%&quot;))
#&gt; [1]   0  10 150
parse_number(c(&quot;$1,234.5&quot;, &quot;$12.45&quot;))
#&gt; [1] 1234.50   12.45
</code></pre>

<h3>Date/times</h3>

<p>readr supports three types of date/time data:</p>

<ul>
<li>dates: number of days since 1970-01-01.</li>
<li>times: number of seconds since midnight.</li>
<li>datetimes: number of seconds since midnight 1970-01-01.</li>
</ul>

<pre><code class="r">parse_datetime(&quot;2010-10-01 21:45&quot;)
#&gt; [1] &quot;2010-10-01 21:45:00 UTC&quot;
parse_date(&quot;2010-10-01&quot;)
#&gt; [1] &quot;2010-10-01&quot;
parse_time(&quot;1:00pm&quot;)
#&gt; 13:00:00
</code></pre>

<p>Each function takes a <code>format</code> argument which describes the format of the string. If not specified, it uses a default value:</p>

<ul>
<li><p><code>parse_datetime()</code> recognises
<a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> 
datetimes.</p></li>
<li><p><code>parse_date()</code> uses the <code>date_format</code> specified by
the <code>locale()</code>. The default value is <code>%AD</code> which uses
an automatic date parser that recognises dates of the 
format <code>Y-m-d</code> or <code>Y/m/d</code>.</p></li>
<li><p><code>parse_time()</code> uses the <code>time_format</code> specified by
the <code>locale()</code>. The default value is <code>%At</code> which uses
an automatic time parser that recognises times of the
form <code>H:M</code> optionally followed by seconds and am/pm.</p></li>
</ul>

<p>In most cases, you will need to supply a <code>format</code>, as documented in <code>parse_datetime()</code>:</p>

<pre><code class="r">parse_datetime(&quot;1 January, 2010&quot;, &quot;%d %B, %Y&quot;)
#&gt; [1] &quot;2010-01-01 UTC&quot;
parse_datetime(&quot;02/02/15&quot;, &quot;%m/%d/%y&quot;)
#&gt; [1] &quot;2015-02-02 UTC&quot;
</code></pre>

<h3>Factors</h3>

<p>When reading a column that has a known set of values, you can read directly into a factor. <code>parse_factor()</code> will generate generate a warning if a value is not in the supplied levels.</p>

<pre><code class="r">parse_factor(c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;), levels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
#&gt; [1] a b a
#&gt; Levels: a b c
parse_factor(c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;), levels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
#&gt; Warning: 1 parsing failure.
#&gt; row col           expected actual
#&gt;   3  -- value in level set      d
#&gt; [1] a    b    &lt;NA&gt;
#&gt; attr(,&quot;problems&quot;)
#&gt; # A tibble: 1 x 4
#&gt;     row   col expected           actual
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt; 
#&gt; 1     3    NA value in level set d     
#&gt; Levels: a b c
</code></pre>

<h2>Column specification</h2>

<p>It would be tedious if you had to specify the type of every column when reading a file. Instead readr, uses some heuristics to guess the type of each column. You can access these results yourself using <code>guess_parser()</code>:</p>

<pre><code class="r">guess_parser(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
#&gt; [1] &quot;character&quot;
guess_parser(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))
#&gt; [1] &quot;double&quot;
guess_parser(c(&quot;1,000&quot;, &quot;2,000&quot;, &quot;3,000&quot;))
#&gt; [1] &quot;number&quot;
guess_parser(c(&quot;2001/10/10&quot;))
#&gt; [1] &quot;date&quot;
</code></pre>

<p>The guessing policies are described in the documentation for the individual functions. Guesses are fairly strict. For example, we don&#39;t guess that currencies are numbers, even though we can parse them:</p>

<pre><code class="r">guess_parser(&quot;$1,234&quot;)
#&gt; [1] &quot;character&quot;
parse_number(&quot;1,234&quot;)
#&gt; [1] 1234
</code></pre>

<p>The are two parsers that will never be guessed: <code>col_skip()</code> and <code>col_factor()</code>. You will always need to supply these explicitly.</p>

<p>You can see the specification that readr would generate for a column file by using <code>spec_csv()</code>, <code>spec_tsv()</code> and so on:</p>

<pre><code class="r">x &lt;- spec_csv(readr_example(&quot;challenge.csv&quot;))
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_logical()
#&gt; )
</code></pre>

<p>For bigger files, you can often make the specification simpler by changing the default column type using <code>cols_condense()</code></p>

<pre><code class="r">mtcars_spec &lt;- spec_csv(readr_example(&quot;mtcars.csv&quot;))
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   mpg = col_double(),
#&gt;   cyl = col_double(),
#&gt;   disp = col_double(),
#&gt;   hp = col_double(),
#&gt;   drat = col_double(),
#&gt;   wt = col_double(),
#&gt;   qsec = col_double(),
#&gt;   vs = col_double(),
#&gt;   am = col_double(),
#&gt;   gear = col_double(),
#&gt;   carb = col_double()
#&gt; )
mtcars_spec
#&gt; cols(
#&gt;   mpg = col_double(),
#&gt;   cyl = col_double(),
#&gt;   disp = col_double(),
#&gt;   hp = col_double(),
#&gt;   drat = col_double(),
#&gt;   wt = col_double(),
#&gt;   qsec = col_double(),
#&gt;   vs = col_double(),
#&gt;   am = col_double(),
#&gt;   gear = col_double(),
#&gt;   carb = col_double()
#&gt; )

cols_condense(mtcars_spec)
#&gt; cols(
#&gt;   .default = col_double()
#&gt; )
</code></pre>

<p>By default readr only looks at the first 1000 rows. This keeps file parsing speedy, but can generate incorrect guesses. For example, in <code>challenge.csv</code> the column types change in row 1001, so readr guesses the wrong types. One way to resolve the problem is to increase the number of rows:</p>

<pre><code class="r">x &lt;- spec_csv(readr_example(&quot;challenge.csv&quot;), guess_max = 1001)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_date(format = &quot;&quot;)
#&gt; )
</code></pre>

<p>Another way is to manually specify the <code>col_type</code>, as described below.</p>

<h2>Rectangular parsers</h2>

<p>readr comes with five parsers for rectangular file formats:</p>

<ul>
<li><code>read_csv()</code> and <code>read_csv2()</code> for csv files</li>
<li><code>read_tsv()</code> for tabs separated files</li>
<li><code>read_fwf()</code> for fixed-width files</li>
<li><code>read_log()</code> for web log files</li>
</ul>

<p>Each of these functions firsts calls <code>spec_xxx()</code> (as described above), and then parses the file according to that column specification:</p>

<pre><code class="r">df1 &lt;- read_csv(readr_example(&quot;challenge.csv&quot;))
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_logical()
#&gt; )
#&gt; Warning: 1000 parsing failures.
#&gt;  row col           expected     actual                                                            file
#&gt; 1001   y 1/0/T/F/TRUE/FALSE 2015-01-16 &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118/readr/extdata/challenge.csv&#39;
#&gt; 1002   y 1/0/T/F/TRUE/FALSE 2018-05-18 &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118/readr/extdata/challenge.csv&#39;
#&gt; 1003   y 1/0/T/F/TRUE/FALSE 2015-09-05 &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118/readr/extdata/challenge.csv&#39;
#&gt; 1004   y 1/0/T/F/TRUE/FALSE 2012-11-28 &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118/readr/extdata/challenge.csv&#39;
#&gt; 1005   y 1/0/T/F/TRUE/FALSE 2020-01-13 &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118/readr/extdata/challenge.csv&#39;
#&gt; .... ... .................. .......... ...............................................................
#&gt; See problems(...) for more details.
</code></pre>

<p>The rectangular parsing functions almost always succeed; they&#39;ll only fail if the format is severely messed up. Instead, readr will generate a data frame of problems. The first few will be printed out, and you can access them all with <code>problems()</code>:</p>

<pre><code class="r">problems(df1)
#&gt; # A tibble: 1,000 x 5
#&gt;      row col   expected       actual   file                               
#&gt;    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;                              
#&gt;  1  1001 y     1/0/T/F/TRUE/… 2015-01… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  2  1002 y     1/0/T/F/TRUE/… 2018-05… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  3  1003 y     1/0/T/F/TRUE/… 2015-09… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  4  1004 y     1/0/T/F/TRUE/… 2012-11… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  5  1005 y     1/0/T/F/TRUE/… 2020-01… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  6  1006 y     1/0/T/F/TRUE/… 2016-04… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  7  1007 y     1/0/T/F/TRUE/… 2011-05… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  8  1008 y     1/0/T/F/TRUE/… 2020-07… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt;  9  1009 y     1/0/T/F/TRUE/… 2011-04… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt; 10  1010 y     1/0/T/F/TRUE/… 2010-05… &#39;/tmp/RtmpVpPyJ3/Rinst2a721c535118…
#&gt; # ... with 990 more rows
</code></pre>

<p>You&#39;ve already seen one way of handling bad guesses: increasing the number of rows used to guess the type of each column. </p>

<pre><code class="r">df2 &lt;- read_csv(readr_example(&quot;challenge.csv&quot;), guess_max = 1001)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_date(format = &quot;&quot;)
#&gt; )
</code></pre>

<p>Another approach is to manually supply the column specification.</p>

<h3>Overriding the defaults</h3>

<p>In the previous examples, you may have noticed that readr printed the column specification that it used to parse the file:</p>

<pre><code class="r">#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   x = col_integer(),
#&gt;   y = col_character()
#&gt; )
</code></pre>

<p>You can also access it after the fact using <code>spec()</code>:</p>

<pre><code class="r">spec(df1)
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_logical()
#&gt; )
spec(df2)
#&gt; cols(
#&gt;   x = col_double(),
#&gt;   y = col_date(format = &quot;&quot;)
#&gt; )
</code></pre>

<p>(This also allows you to access the full column specification if you&#39;re reading a very wide file. By default, readr will only print the specification of the first 20 columns.)</p>

<p>If you want to manually specify the column types, you can start by copying and pasting this code, and then tweaking it fix the parsing problems.</p>

<pre><code class="r">df3 &lt;- read_csv(
  readr_example(&quot;challenge.csv&quot;), 
  col_types = cols(
    x = col_double(),
    y = col_date(format = &quot;&quot;)
  )
)
</code></pre>

<p>In general, it&#39;s good practice to supply an explicit column specification. It is more work, but it ensures that you get warnings if the data changes in unexpected ways. To be really strict, you can use <code>stop_for_problems(df3)</code>. This will throw an error if there are any parsing problems, forcing you to fix those problems before proceeding with the analysis.</p>

<h3>Output</h3>

<p>The output of all these functions is a tibble. Note that characters are never automatically converted to factors (i.e. no more <code>stringsAsFactors = FALSE</code>) and column names are left as is, not munged into valid R identifiers (i.e. there is no <code>check.names = TRUE</code>). Row names are never set.</p>

<p>Attributes store the column specification (<code>spec()</code>) and any parsing problems (<code>problems()</code>).</p>

</body>

</html>
