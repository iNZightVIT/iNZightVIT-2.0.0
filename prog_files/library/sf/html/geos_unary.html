<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Geometric unary operations on simple feature geometry sets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for geos_unary {sf}"><tr><td>geos_unary {sf}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Geometric unary operations on simple feature geometry sets</h2>

<h3>Description</h3>

<p>Geometric unary operations on simple feature geometry sets. These are all generics, with methods for <code>sfg</code>, <code>sfc</code> and <code>sf</code> objects, returning an object of the same class.
</p>


<h3>Usage</h3>

<pre>
st_buffer(x, dist, nQuadSegs = 30)

st_boundary(x)

st_convex_hull(x)

st_simplify(x, preserveTopology = FALSE, dTolerance = 0)

st_triangulate(x, dTolerance = 0, bOnlyEdges = FALSE)

st_voronoi(x, envelope, dTolerance = 0, bOnlyEdges = FALSE)

st_polygonize(x)

st_line_merge(x)

st_centroid(x, ..., of_largest_polygon = FALSE)

st_point_on_surface(x)

st_node(x)

st_segmentize(x, dfMaxLength, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfg</code> or <code>sf</code></p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>numeric; buffer distance for all, or for each of the elements in <code>x</code>; in case
<code>dist</code> is a <code>units</code> object, it should be convertible to <code>arc_degree</code> if
<code>x</code> has geographic coordinates, and to <code>st_crs(x)$units</code> otherwise</p>
</td></tr>
<tr valign="top"><td><code>nQuadSegs</code></td>
<td>
<p>integer; number of segments per quadrant (fourth of a circle)</p>
</td></tr>
<tr valign="top"><td><code>preserveTopology</code></td>
<td>
<p>logical; carry out topology preserving simplification?</p>
</td></tr>
<tr valign="top"><td><code>dTolerance</code></td>
<td>
<p>numeric; tolerance parameter</p>
</td></tr>
<tr valign="top"><td><code>bOnlyEdges</code></td>
<td>
<p>logical; if TRUE, return lines, else return polygons</p>
</td></tr>
<tr valign="top"><td><code>envelope</code></td>
<td>
<p>object of class <code>sfc</code> or <code>sfg</code> containing a <code>POLYGON</code> with the envelope for a voronoi diagram; this only takes effect when it is larger than the default envelope, chosen when <code>envelope</code> is an empty polygon</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr valign="top"><td><code>of_largest_polygon</code></td>
<td>
<p>logical; for <code>st_centroid</code>: if <code>TRUE</code>, return centroid of the largest (sub)polygon of a <code>MULTIPOLYGON</code> rather than of the whole <code>MULTIPOLYGON</code></p>
</td></tr>
<tr valign="top"><td><code>dfMaxLength</code></td>
<td>
<p>maximum length of a line segment. If <code>x</code> has geographical coordinates (long/lat), <code>dfMaxLength</code> is either a numeric expressed in meter, or an object of class <code>units</code> with length units or unit <code>rad</code> or <code>degree</code>; segmentation takes place along the great circle, using <a href="../../lwgeom/html/st_geod_segmentize.html">st_geod_segmentize</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_triangulate</code> requires GEOS version 3.4 or above
</p>
<p><code>st_voronoi</code> requires GEOS version 3.5 or above
</p>
<p>in case of <code>st_polygonize</code>, <code>x</code> must be an object of class <code>LINESTRING</code> or <code>MULTILINESTRING</code>, or an <code>sfc</code> geometry list-column object containing these
</p>
<p>in case of <code>st_line_merge</code>, <code>x</code> must be an object of class <code>MULTILINESTRING</code>, or an <code>sfc</code> geometry list-column object containing these
</p>
<p><code>st_point_on_surface</code> returns a point guaranteed to be on the (multi)surface.
</p>
<p><code>st_node</code> adds nodes to linear geometries at intersections without a node, and only works on individual linear geometries
</p>


<h3>Value</h3>

<p>an object of the same class of <code>x</code>, with manipulated geometry.
</p>


<h3>Examples</h3>

<pre>
nc = st_read(system.file("shape/nc.shp", package="sf"))
plot(st_convex_hull(nc))
plot(nc, border = grey(.5))
set.seed(1)
x = st_multipoint(matrix(runif(10),,2))
box = st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
if (sf_extSoftVersion()["GEOS"] &gt;= "3.5.0") {
 v = st_sfc(st_voronoi(x, st_sfc(box)))
 plot(v, col = 0, border = 1, axes = TRUE)
 plot(box, add = TRUE, col = 0, border = 1) # a larger box is returned, as documented
 plot(x, add = TRUE, col = 'red', cex=2, pch=16)
 plot(st_intersection(st_cast(v), box)) # clip to smaller box
 plot(x, add = TRUE, col = 'red', cex=2, pch=16)
}
mls = st_multilinestring(list(matrix(c(0,0,0,1,1,1,0,0),,2,byrow=TRUE)))
st_polygonize(st_sfc(mls))
mls = st_multilinestring(list(rbind(c(0,0), c(1,1)), rbind(c(2,0), c(1,1))))
st_line_merge(st_sfc(mls))
plot(nc, axes = TRUE)
plot(st_centroid(nc), add = TRUE, pch = 3)
mp = st_combine(st_buffer(st_sfc(lapply(1:3, function(x) st_point(c(x,x)))), 0.2 * 1:3))
plot(mp)
plot(st_centroid(mp), add = TRUE, col = 'red') # centroid of combined geometry
plot(st_centroid(mp, of_largest_polygon = TRUE), add = TRUE, col = 'blue', pch = 3)
plot(nc, axes = TRUE)
plot(st_point_on_surface(nc), add = TRUE, pch = 3)
(l = st_linestring(rbind(c(0,0), c(1,1), c(0,1), c(1,0), c(0,0))))
st_polygonize(st_node(l))
st_node(st_multilinestring(list(rbind(c(0,0), c(1,1), c(0,1), c(1,0), c(0,0)))))
sf = st_sf(a=1, geom=st_sfc(st_linestring(rbind(c(0,0),c(1,1)))), crs = 4326)
seg = st_segmentize(sf, units::set_units(100, km))
seg = st_segmentize(sf, units::set_units(0.01, rad))
nrow(seg$geom[[1]])
</pre>

<hr /><div style="text-align: center;">[Package <em>sf</em> version 0.6-2 <a href="00Index.html">Index</a>]</div>
</body></html>
